import 'package:easy_localization/easy_localization.dart';
import 'package:flx_nocode_flutter/features/component/models/component.dart';
import 'package:flx_nocode_flutter/features/component/models/component_date_picker.dart';
import 'package:flx_nocode_flutter/features/component/models/component_dropdown.dart';
import 'package:flx_nocode_flutter/features/component/models/component_number_field.dart';
import 'package:flx_nocode_flutter/features/component/models/component_text_field.dart';
import 'package:flx_nocode_flutter/features/field/domain/extensions/entity_field_extensions.dart';
import 'package:flx_nocode_flutter/features/field/models/field.dart';
import 'package:flx_nocode_flutter/core/utils/js/string_js_interpolation.dart';
import 'package:flutter/material.dart';

/// Utility class for [CreatePageController] to handle data processing and formatting.
class CreatePageControllerUtils {
  /// Processes the initial data for the form by interpolating JavaScript expressions.
  ///
  /// It iterates through all [components] and resolves their initial values using
  /// the provided [data] and [parentData] as context.
  static Map<String, dynamic> prepareInitialData({
    required Map<String, dynamic> initialDataInput,
    required List<Component> components,
    required List<Map<String, dynamic>> parentData,
  }) {
    final data = Map<String, dynamic>.from(initialDataInput);

    for (final component in components) {
      String? initialValue;
      if (component is ComponentTextField) {
        initialValue = component.initialValue;
      } else if (component is ComponentDatePicker) {
        initialValue = component.initialValue;
      } else if (component is ComponentNumberField) {
        initialValue = component.initialValue;
      } else if (component is ComponentDropdown) {
        initialValue = component.initialValue;
      }

      if (initialValue != null) {
        if (initialValue.isNotEmpty) {
          final val = initialValue.interpolateJavascript({
            'data': data,
            if (parentData.isNotEmpty) 'parent': parentData.last,
          });
          data[component.id] = val;
        } else {
          data.remove(component.id);
        }
      }
    }
    return data;
  }

  /// Extracts the current values from the form [controllers] and formats them.
  ///
  /// It processes both UI components and raw entity fields, applying date/time
  /// formatting where necessary.
  static Map<String, dynamic> extractCurrentData({
    required List<Component> components,
    required List<EntityField> fields,
    required Map<String, TextEditingController> controllers,
  }) {
    final data = <String, dynamic>{};
    final fieldMap = {for (final f in fields) f.reference: f};

    for (final component in components) {
      final controller = controllers[component.id];
      if (controller == null) continue;

      var value = controller.text;
      final field = fieldMap[component.id];

      // Handle date formatting
      if (component is ComponentDatePicker) {
        value = formatDateTimeField(field, value,
            customFormat: component.dateFormat);
      } else if (field != null && field.isDateTime) {
        value = formatDateTimeField(field, value);
      }

      data[component.id] = value;
    }

    // Include pure field data not present in components list
    for (final field in fields) {
      if (!data.containsKey(field.reference)) {
        if (field.reference != 'id' && (field.autoGenerated ?? false)) {
          continue;
        }
        final controller = controllers[field.reference];
        if (controller != null) {
          var value = controller.text;
          if (field.isDateTime) {
            value = formatDateTimeField(field, value);
          }
          data[field.reference] = value;
        }
      }
    }

    return data;
  }

  /// Formats a string [value] to a standard date/time format.
  ///
  /// Uses the [field]'s configured format or falls back to 'yyyy-MM-dd HH:mm:ss'.
  static String formatDateTimeField(EntityField? field, String value,
      {String? customFormat}) {
    if (value.isEmpty) return value;

    final fmt = (customFormat != null && customFormat.isNotEmpty)
        ? customFormat
        : (field == null || field.dateTimeFormat.isEmpty)
            ? 'yyyy-MM-dd HH:mm:ss'
            : field.dateTimeFormat;

    final formatter = DateFormat(fmt);

    DateTime? parsed;
    try {
      parsed = formatter.parse(value);
    } catch (_) {
      parsed = DateTime.tryParse(value);
    }

    if (parsed == null) return value;
    return formatter.format(parsed);
  }
}
