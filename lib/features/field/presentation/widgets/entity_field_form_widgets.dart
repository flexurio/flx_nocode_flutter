import 'package:easy_localization/easy_localization.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flx_authentication_flutter/flx_authentication_flutter.dart';
import 'package:flx_core_flutter/flx_core_flutter.dart';
import 'package:flx_nocode_flutter/features/field/models/field.dart';
import 'package:form_field_validator/form_field_validator.dart';

import 'package:flx_nocode_flutter/features/field/domain/extensions/entity_field_extensions.dart';
import 'package:flx_nocode_flutter/features/field/models/type.dart';
import 'package:flx_nocode_flutter/src/app/view/widget/entity_drop_down.dart';

extension EntityFieldFormWidgetsX on EntityField {
  /// Determines if the field should be enabled based on the current action.
  bool _enabled(DataAction action) {
    if (autoGenerated ?? false) return false;

    return switch (action) {
      DataAction.create => allowCreate ?? false,
      DataAction.edit => allowUpdate ?? false,
      _ => false,
    };
  }

  /// Dispatches the creation of the appropriate form widget based on field type.
  Widget buildForm(
    DataAction action,
    TextEditingController controller,
    List<Map<String, dynamic>> parentData,
  ) {
    final isEnabled = _enabled(action);

    if (optionsSource != null) {
      return buildFieldDropDown(action, controller, isEnabled, parentData);
    }

    return switch (typeEnum) {
      EntityFieldType.dateTime =>
        buildFieldDateTime(action, controller, isEnabled),
      EntityFieldType.bool => buildFieldBool(action, controller, isEnabled),
      _ when isPermission =>
        buildFieldPermission(action, controller, isEnabled),
      _ => buildFieldText(action, controller, isEnabled),
    };
  }

  Widget buildFieldBool(
    DataAction action,
    TextEditingController controller,
    bool isEnabled,
  ) {
    final raw = controller.text.trim().toLowerCase();
    final value = raw == '1' || raw == 'true';
    // Normalise controller value so unchecked defaults to "0" instead of empty.
    if (raw.isEmpty) controller.text = '0';
    return AbsorbPointer(
      absorbing: !isEnabled,
      child: FieldCheckBox(
        label: label,
        initialValue: value,
        onChanged: (value) => controller.text = value ? '1' : '0',
      ),
    );
  }

  Widget buildFieldPermission(
    DataAction action,
    TextEditingController controller,
    bool isEnabled,
  ) {
    return AbsorbPointer(
      absorbing: !isEnabled,
      child: FieldCheckboxPermission(
        initialValue: Access.fromValue(int.tryParse(controller.text) ?? 0),
        onChanged: (value) {
          controller.text = value.getValue().toString();
        },
      ),
    );
  }

  Widget buildFieldDateTime(
    DataAction action,
    TextEditingController controller,
    bool isEnabled,
  ) {
    final fmt = _dateFormatSafe();
    final value = controller.text;
    DateTime? initialDate;
    try {
      if (value != 'null' && value.isNotEmpty) {
        initialDate =
            DateFormat(fmt).tryParse(value) ?? DateTime.tryParse(value);
        if (initialDate != null) {
          // Normalise the controller text to the configured format.
          controller.text = DateFormat(fmt).format(initialDate);
        }
      }
    } catch (e) {
      debugPrint('[EntityField] datetime parse error for "$value": $e');
    }

    return FieldDatePicker(
      enabled: isEnabled,
      labelText: label,
      initialSelectedDate: initialDate,
      controller: controller,
      onChanged: (date) => controller.text = DateFormat(fmt).format(date),
      validator: requiredObjectValidator.call,
    );
  }

  Widget buildFieldDropDown(
    DataAction action,
    TextEditingController controller,
    bool isEnabled,
    List<Map<String, dynamic>> parentData,
  ) {
    return FDropDownSearchEntity(
      parentData: parentData,
      label: label,
      itemAsString: (id, label) => '$id - $label',
      entityField: this,
      initialValue: action.isEdit ? MapEntry(controller.text, '') : null,
      enabled: isEnabled,
      isRequired: this.required,
      onChanged: (value) {
        controller.text = value!.key.toString();
      },
    );
  }

  Widget buildFieldText(
    DataAction action,
    TextEditingController controller,
    bool isEnabled,
  ) {
    return FTextFormField(
      labelText: label,
      enabled: isEnabled,
      controller: controller,
      inputFormatters:
          isNumber ? [FilteringTextInputFormatter.digitsOnly] : null,
      validator: MultiValidator([
        if (this.required) requiredValidator,
        LengthValidator(
          minLength: minLength,
          maxLength: maxLength,
        ),
        if (pattern != null)
          PatternValidator(
            pattern!,
            errorText: patternError ?? 'Invalid format',
          ),
      ]),
    );
  }

  /// Returns configured datetime format; falls back to ISO-like default
  /// to avoid crashes if the type string is malformed.
  String _dateFormatSafe() => dateTimeFormat;
}
