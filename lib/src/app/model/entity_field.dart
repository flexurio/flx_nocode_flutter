import 'package:flx_nocode_flutter/src/app/model/entity.dart';
import 'package:flx_nocode_flutter/src/app/model/layout_list_tile.dart';
import 'package:flx_nocode_flutter/src/app/view/widget/entity_drop_down.dart';
import 'package:easy_localization/easy_localization.dart';
import 'package:flx_core_flutter/flx_core_flutter.dart';
import 'package:flutter/material.dart';
import 'package:form_field_validator/form_field_validator.dart';

class EntityField {
  final String label;
  final String reference;
  final String type;
  final double? columnWidth;
  final bool? autoGenerated;
  final bool? required;
  final String? pattern;
  final String? patternError;
  final String? optionsSource;
  final int? minLength;
  final int? maxLength;
  final bool? allowCreate;
  final bool? allowUpdate;
  final FieldOptions? options;

  EntityField({
    required this.label,
    required this.reference,
    required this.type,
    this.columnWidth,
    this.autoGenerated,
    this.required,
    this.pattern,
    this.patternError,
    this.optionsSource,
    this.minLength,
    this.maxLength,
    this.allowCreate,
    this.allowUpdate,
    this.options,
  });

  factory EntityField.fromJson(Map<String, dynamic> json) {
    return EntityField(
      optionsSource: json['options_source'],
      columnWidth: (json['column_width'] as num?)?.toDouble(),
      label: json['label'],
      reference: json['reference'],
      type: json['type'],
      autoGenerated: json['auto_generated'],
      required: json['required'],
      pattern: json['pattern'],
      patternError: json['pattern_error'],
      minLength: json['min_length'],
      maxLength: json['max_length'],
      allowCreate: json['allow_create'],
      allowUpdate: json['allow_update'],
    );
  }

  Widget buildInputField(DataAction action, TextEditingController controller) {
    final isEnabled = _enabled(action);
    if (optionsSource != null) {
      return FDropDownSearchEntity(
        label: label,
        itemAsString: (id, label) => '$id - $label',
        entityField: this,
        initialValue: action.isEdit ? MapEntry(controller.text, '') : null,
        enabled: isEnabled,
        onChanged: (value) {
          controller.text = value!.key.toString();
        },
      );
    } else if (isDateTime) {
      final initialDate = action.isEdit
          ? (DateTime.tryParse(controller.text) ??
              DateFormat.yMMMMd().parse(controller.text))
          : null;
      return FieldDatePicker(
        labelText: label,
        initialSelectedDate: initialDate,
        controller: controller,
        validator: requiredObjectValidator.call,
      );
    } else if (isBool) {
      final value = controller.text == '1' ? true : false;
      return AbsorbPointer(
        absorbing: !isEnabled,
        child: Container(
          padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 6),
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(12),
            color: isEnabled ? null : Colors.blueGrey.shade100,
            border: Border.all(color: Colors.grey.shade300),
          ),
          child: CheckboxWithText(
            onChanged: (value) => controller.text = value ? '1' : '0',
            initialValue: value,
            text: '$label' + (isEnabled ? '' : ' (Read Only)'),
          ),
        ),
      );
    }

    return FTextFormField(
      labelText: label,
      enabled: isEnabled,
      controller: controller,
      validator: MultiValidator([
        if (required ?? false) requiredValidator,
        LengthValidator(
          minLength: minLength,
          maxLength: maxLength,
        ),
        if (pattern != null)
          PatternValidator(
            pattern!,
            errorText: patternError ?? 'Invalid format',
          ),
      ]),
    );
  }

  static Widget buildDisplay(EntityCustom entity, String label, dynamic value,
      [void Function()? onTap]) {
    if (value == null) {
      return Text('-');
    }

    final field = entity.fields.firstWhere((e) => e.reference == label);
    late Widget widget;
    if (field.isDateTime) {
      final date = DateTime.parse(value);
      widget = Text(DateFormat(field.dateTimeFormat).format(date));
    } else if (field.isBool) {
      widget = BoolIcon(value == 1);
    } else {
      widget = Text(LayoutListTile.getValue(value));
    }

    if (widget is Text && onTap != null) {
      return widget.canCopy(onTap: onTap);
    }
    return widget;
  }

  bool _enabled(DataAction action) {
    if (action == DataAction.create) {
      return allowCreate ?? false;
    } else if (action == DataAction.edit) {
      return allowUpdate ?? false;
    } else {
      return false;
    }
  }

  bool get isDateTime => type.contains('datetime');
  bool get isBool => type == 'bool';

  String get dateTimeFormat {
    final regex = RegExp(r'datetime\((.*?)\)');
    final matches = regex.allMatches(type);

    for (final match in matches) {
      return match.group(1) as String;
    }
    throw Exception('Invalid datetime format');
  }

  Map<String, dynamic> toJson() {
    return {
      'source': optionsSource,
      'column_width': columnWidth,
      'label': label,
      'reference': reference,
      'type': type,
      'auto_generated': autoGenerated,
      'required': required,
      'pattern': pattern,
      'min_length': minLength,
      'max_length': maxLength,
      'allow_create': allowCreate,
      'allow_update': allowUpdate,
    };
  }
}
