import 'package:flexurio_no_code/src/app/model/entity.dart';
import 'package:flexurio_no_code/src/app/view/widget/entity_drop_down.dart';
import 'package:easy_localization/easy_localization.dart';
import 'package:flexurio_erp_core/flexurio_erp_core.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:form_field_validator/form_field_validator.dart';
import 'package:gap/gap.dart';

class EntityField {
  final String label;
  final String reference;
  final String type;
  final double? columnWidth;
  final bool? autoGenerated;
  final bool? required;
  final String? pattern;
  final String? source;
  final int? minLength;
  final int? maxLength;
  final bool? allowCreate;
  final bool? allowUpdate;
  final FieldOptions? options;

  EntityField({
    required this.label,
    required this.reference,
    required this.type,
    this.columnWidth,
    this.autoGenerated,
    this.required,
    this.pattern,
    this.source,
    this.minLength,
    this.maxLength,
    this.allowCreate,
    this.allowUpdate,
    this.options,
  });

  factory EntityField.fromJson(Map<String, dynamic> json) {
    return EntityField(
      source: json['source'],
      columnWidth: (json['column_width'] as num?)?.toDouble(),
      label: json['label'],
      reference: json['reference'],
      type: json['type'],
      autoGenerated: json['auto_generated'],
      required: json['required'],
      pattern: json['pattern'],
      minLength: json['min_length'],
      maxLength: json['max_length'],
      allowCreate: json['allow_create'],
      allowUpdate: json['allow_update'],
      options: json['options'] != null
          ? FieldOptions.fromJson(json['options'])
          : null,
    );
  }

  (String entity, String key, String value) get backendSource {
    if (source == null) {
      throw Exception('Source is null');
    }

    final pattern =
        r'(?<type>\w+)\.(?<entity>\w+)\(\{(?<key>\w+)\}-{(?<value>\w+)}\)';

    final regExp = RegExp(pattern);
    final match = regExp.firstMatch(source!);

    String entity = '';
    String key = '';
    String value = '';

    if (match != null) {
      entity = match.namedGroup('entity')!;
      key = match.namedGroup('key')!;
      value = match.namedGroup('value')!;
    }

    return (entity, key, value);
  }

  Widget buildFieldDropDown(
    DataAction action,
    TextEditingController controller,
    bool isEnabled,
  ) {
    return FDropDownSearchEntity(
      itemAsString: (id, label) => '$id - $label',
      entityField: this,
      initialValue: action.isEdit ? {'id': controller.text} : null,
      enabled: isEnabled,
      onChanged: (value) {
        controller.text = value!['id'].toString();
      },
    );
  }

  Widget buildFieldBool(
    DataAction action,
    TextEditingController controller,
    bool isEnabled,
  ) {
    final value = controller.text == '1' ? true : false;
    return AbsorbPointer(
      absorbing: !isEnabled,
      child: FieldCheckBox(
        label: label,
        initialValue: value,
        onChanged: (value) => controller.text = value ? '1' : '0',
      ),
    );
  }

  Widget buildFieldPermission(
    DataAction action,
    TextEditingController controller,
    bool isEnabled,
  ) {
    return AbsorbPointer(
      absorbing: !isEnabled,
      child: FieldCheckboxPermission(
        initialValue: Access.fromValue(int.tryParse(controller.text) ?? 0),
        onChanged: (value) => controller.text = value.getValue().toString(),
      ),
    );
  }

  Widget buildFieldDateTime(
    DataAction action,
    TextEditingController controller,
    bool isEnabled,
  ) {
    final initialDate = action.isEdit
        ? (DateTime.tryParse(controller.text) ??
            DateFormat.yMMMMd().parse(controller.text))
        : null;
    return FieldDatePicker(
      labelText: label,
      initialSelectedDate: initialDate,
      controller: controller,
      validator: requiredObjectValidator.call,
    );
  }

  Widget buildFieldText(
    DataAction action,
    TextEditingController controller,
    bool isEnabled,
  ) {
    return FTextFormField(
      labelText: label,
      enabled: isEnabled,
      controller: controller,
      inputFormatters:
          type == 'number' ? [FilteringTextInputFormatter.digitsOnly] : null,
      validator: MultiValidator([
        if (required ?? false) requiredValidator,
        LengthValidator(
          minLength: minLength,
          maxLength: maxLength,
        ),
      ]),
    );
  }

  Widget buildForm(DataAction action, TextEditingController controller) {
    final isEnabled = _enabled(action);
    if (source != null) {
      return buildFieldDropDown(action, controller, isEnabled);
    } else if (isDateTime) {
      return buildFieldDateTime(action, controller, isEnabled);
    } else if (isBool) {
      return buildFieldBool(action, controller, isEnabled);
    } else if (isPermission) {
      return buildFieldPermission(action, controller, isEnabled);
    }

    return buildFieldText(action, controller, isEnabled);
  }

  static Widget buildDisplay(EntityCustom entity, String label, dynamic value,
      [void Function()? onTap]) {
    if (value == null) {
      return Text('-');
    }

    final field = entity.fields.firstWhere((e) => e.reference == label);
    late Widget widget;
    if (field.isDateTime) {
      final date = DateTime.parse(value);
      widget = Text(DateFormat(field.dateTimeFormat).format(date));
    } else if (field.isBool) {
      widget = BoolIcon(value == 1);
    } else {
      widget = Text(value.toString());
    }

    if (widget is Text && onTap != null) {
      return widget.canCopy(onTap: onTap);
    }
    return widget;
  }

  bool _enabled(DataAction action) {
    if (action == DataAction.create) {
      return allowCreate ?? false;
    } else if (action == DataAction.edit) {
      return allowUpdate ?? false;
    } else {
      return false;
    }
  }

  bool get isDateTime => type.contains('datetime');
  bool get isBool => type == 'bool';
  bool get isPermission => type == 'permission';

  String get dateTimeFormat {
    final regex = RegExp(r'datetime\((.*?)\)');
    final matches = regex.allMatches(type);

    for (final match in matches) {
      return match.group(1) as String;
    }
    throw Exception('Invalid datetime format');
  }

  Map<String, dynamic> toJson() {
    return {
      'source': source,
      'column_width': columnWidth,
      'label': label,
      'reference': reference,
      'type': type,
      'auto_generated': autoGenerated,
      'required': required,
      'pattern': pattern,
      'min_length': minLength,
      'max_length': maxLength,
      'allow_create': allowCreate,
      'allow_update': allowUpdate,
      'options': options?.toJson(),
    };
  }
}

class FieldOptions {
  final String source;
  final String labelField;
  final String valueField;

  FieldOptions({
    required this.source,
    required this.labelField,
    required this.valueField,
  });

  factory FieldOptions.fromJson(Map<String, dynamic> json) {
    return FieldOptions(
      source: json['source'],
      labelField: json['label_field'],
      valueField: json['value_field'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'source': source,
      'label_field': labelField,
      'value_field': valueField,
    };
  }
}

class Access {
  final bool delete;
  final bool write;
  final bool read;
  final bool execute;

  Access({
    required this.delete,
    required this.write,
    required this.read,
    required this.execute,
  });

  int getValue() {
    return (delete ? 1 : 0) +
        (write ? 2 : 0) +
        (read ? 4 : 0) +
        (execute ? 8 : 0);
  }

  static Access fromValue(int value) {
    return Access(
      delete: (value & 1) == 1,
      write: (value & 2) == 2,
      read: (value & 4) == 4,
      execute: (value & 8) == 8,
    );
  }

  Access copyWith({
    bool? delete,
    bool? write,
    bool? read,
    bool? execute,
  }) {
    return Access(
      delete: delete ?? this.delete,
      write: write ?? this.write,
      read: read ?? this.read,
      execute: execute ?? this.execute,
    );
  }
}

class FieldCheckboxPermission extends StatelessWidget {
  const FieldCheckboxPermission({
    required this.initialValue,
    required this.onChanged,
    super.key,
  });
  final Access initialValue;
  final void Function(Access) onChanged;

  void _onChanged(String event, bool value) {
    if (event == 'delete') {
      onChanged(initialValue.copyWith(delete: value));
    } else if (event == 'write') {
      onChanged(initialValue.copyWith(write: value));
    } else if (event == 'read') {
      onChanged(initialValue.copyWith(read: value));
    } else if (event == 'execute') {
      onChanged(initialValue.copyWith(execute: value));
    }
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        FieldCheckBox(
          label: 'delete'.tr(),
          initialValue: initialValue.delete,
          onChanged: (value) => _onChanged('delete', value),
        ),
        Gap(12),
        FieldCheckBox(
          label: 'write'.tr(),
          initialValue: initialValue.write,
          onChanged: (value) => _onChanged('write', value),
        ),
        Gap(12),
        FieldCheckBox(
          label: 'read'.tr(),
          initialValue: initialValue.read,
          onChanged: (value) => _onChanged('read', value),
        ),
        Gap(12),
        FieldCheckBox(
          label: 'execute'.tr(),
          initialValue: initialValue.execute,
          onChanged: (value) => _onChanged('execute', value),
        ),
      ],
    );
  }
}
