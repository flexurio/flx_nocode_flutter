import 'package:easy_localization/easy_localization.dart';
import 'package:flx_nocode_flutter/features/component/models/component.dart';
import 'package:flx_nocode_flutter/features/component/models/component_date_picker.dart';
import 'package:flx_nocode_flutter/features/component/models/component_dropdown.dart';
import 'package:flx_nocode_flutter/features/component/models/component_number_field.dart';
import 'package:flx_nocode_flutter/features/component/models/component_text_field.dart';
import 'package:flx_nocode_flutter/features/field/domain/extensions/entity_field_extensions.dart';
import 'package:flx_nocode_flutter/features/field/models/field.dart';
import 'package:flx_nocode_flutter/core/utils/js/string_js_interpolation.dart';
import 'package:flutter/material.dart';

/// Utility class for [CreatePageController] to handle data processing and formatting.
class CreatePageControllerUtils {
  /// Processes the initial data for the form by interpolating JavaScript expressions.
  ///
  /// It iterates through all [components] and resolves their initial values using
  /// the provided [data] and [parentData] as context.
  static Map<String, dynamic> prepareInitialData({
    required Map<String, dynamic> initialDataInput,
    required List<Component> components,
    required List<Map<String, dynamic>> parentData,
  }) {
    final data = Map<String, dynamic>.from(initialDataInput);

    for (final component in components) {
      final initialValue = switch (component) {
        ComponentTextField c => c.initialValue,
        ComponentDatePicker c => c.initialValue,
        ComponentNumberField c => c.initialValue,
        ComponentDropdown c => c.initialValue,
        _ => null,
      };

      if (initialValue != null && initialValue.isNotEmpty) {
        data[component.id] = initialValue.interpolateJavascript({
          'data': data,
          if (parentData.isNotEmpty) 'parent': parentData.last,
        });
      } else if (initialValue != null) {
        data.remove(component.id);
      }
    }
    return data;
  }

  /// Extracts the current values from the form [controllers] and formats them.
  ///
  /// It processes both UI components and raw entity fields, applying date/time
  /// formatting where necessary.
  static Map<String, dynamic> extractCurrentData({
    required List<Component> components,
    required List<EntityField> fields,
    required Map<String, TextEditingController> controllers,
  }) {
    final data = <String, dynamic>{};
    final fieldMap = {for (final f in fields) f.reference: f};

    // 1. Process data from UI components
    for (final component in components) {
      final controller = controllers[component.id];
      if (controller == null) continue;

      final field = fieldMap[component.id];
      data[component.id] = switch (component) {
        ComponentDatePicker c => formatDateTimeField(
            field,
            controller.text,
            customFormat: c.dateFormat,
          ),
        _ when field?.isDateTime ?? false => formatDateTimeField(
            field,
            controller.text,
          ),
        _ => controller.text,
      };
    }

    // 2. Include pure field data not present in UI components
    for (final field in fields) {
      if (data.containsKey(field.reference)) continue;
      if (field.reference != 'id' && (field.autoGenerated ?? false)) continue;

      final controller = controllers[field.reference];
      if (controller != null) {
        data[field.reference] = field.isDateTime
            ? formatDateTimeField(field, controller.text)
            : controller.text;
      }
    }

    return data;
  }

  /// Formats a string [value] to a standard date/time format.
  ///
  /// Uses the [field]'s configured format or falls back to 'yyyy-MM-dd HH:mm:ss'.
  static String formatDateTimeField(
    EntityField? field,
    String value, {
    String? customFormat,
  }) {
    if (value.isEmpty) return value;

    final fmt = customFormat?.isNotEmpty == true
        ? customFormat!
        : (field?.dateTimeFormat.isNotEmpty == true)
            ? field!.dateTimeFormat
            : 'yyyy-MM-dd HH:mm:ss';

    final formatter = DateFormat(fmt);

    final parsed = () {
      try {
        return formatter.parse(value);
      } catch (_) {
        return DateTime.tryParse(value);
      }
    }();

    return parsed != null ? formatter.format(parsed) : value;
  }
}
