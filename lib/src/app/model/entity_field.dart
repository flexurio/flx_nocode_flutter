import 'package:flutter/services.dart';
import 'package:flx_authentication_flutter/flx_authentication_flutter.dart';
import 'package:hive_ce/hive.dart';
import 'package:flx_nocode_flutter/src/app/model/entity.dart';
import 'package:flx_nocode_flutter/src/app/model/layout_list_tile.dart';
import 'package:easy_localization/easy_localization.dart';
import 'package:flx_core_flutter/flx_core_flutter.dart';
import 'package:flutter/material.dart';
import 'package:flx_nocode_flutter/src/app/view/widget/entity_drop_down.dart';
import 'package:form_field_validator/form_field_validator.dart';

enum EntityFieldType {
  text('text'),
  number('number'),
  bool('bool');

  const EntityFieldType(this.id);

  static List<EntityFieldType> get list => [text, number, bool];

  static EntityFieldType fromId(String id) =>
      EntityFieldType.values.firstWhere((element) => element.id == id);

  final String id;

  IconData get icon {
    switch (this) {
      case EntityFieldType.text:
        return Icons.text_fields;
      case EntityFieldType.number:
        return Icons.tag;
      case EntityFieldType.bool:
        return Icons.toggle_on;
    }
  }
}

class EntityField extends HiveObject {
  final String label;
  final String reference;
  final String type;
  final double? columnWidth;
  final bool? autoGenerated;
  final bool? required;
  final String? pattern;
  final String? patternError;
  final String? optionsSource;
  final int? minLength;
  final int? maxLength;
  final bool? allowCreate;
  final bool? allowUpdate;
  final FieldOptions? options;

  EntityField({
    required this.label,
    required this.reference,
    required this.type,
    this.columnWidth,
    this.autoGenerated,
    this.required,
    this.pattern,
    this.patternError,
    this.optionsSource,
    this.minLength,
    this.maxLength,
    this.allowCreate,
    this.allowUpdate,
    this.options,
  });

  factory EntityField.fromJson(Map<String, dynamic> json) {
    return EntityField(
      optionsSource: json['options_source'],
      columnWidth: (json['column_width'] as num?)?.toDouble(),
      label: json['label'],
      reference: json['reference'],
      type: json['type'],
      autoGenerated: json['auto_generated'],
      required: json['required'],
      pattern: json['pattern'],
      patternError: json['pattern_error'],
      minLength: json['min_length'],
      maxLength: json['max_length'],
      allowCreate: json['allow_create'],
      allowUpdate: json['allow_update'],
    );
  }

  factory EntityField.empty() => EntityField(
        label: '',
        reference: '',
        type: '',
      );

  EntityField copyWith({
    String? label,
    String? reference,
    String? type,
    double? columnWidth,
    bool? autoGenerated,
    bool? required,
    String? pattern,
    String? patternError,
    String? optionsSource,
    int? minLength,
    int? maxLength,
    bool? allowCreate,
    bool? allowUpdate,
    FieldOptions? options,
  }) {
    return EntityField(
      label: label ?? this.label,
      reference: reference ?? this.reference,
      type: type ?? this.type,
      columnWidth: columnWidth ?? this.columnWidth,
      autoGenerated: autoGenerated ?? this.autoGenerated,
      required: required ?? this.required,
      pattern: pattern ?? this.pattern,
      patternError: patternError ?? this.patternError,
      optionsSource: optionsSource ?? this.optionsSource,
      minLength: minLength ?? this.minLength,
      maxLength: maxLength ?? this.maxLength,
      allowCreate: allowCreate ?? this.allowCreate,
      allowUpdate: allowUpdate ?? this.allowUpdate,
      options: options ?? this.options,
    );
  }

  dynamic dummyValue() {
    if (isNumber) {
      return 1;
    }
    return 'Sample text here';
  }

  EntityFieldType get typeEnum {
    if (isNumber) return EntityFieldType.number;
    if (isBool) return EntityFieldType.bool;
    return EntityFieldType.text;
  }

  int get decimal {
    if (isNumber) {
      final regExp = RegExp(r'number\((\d+)\)');
      final match = regExp.firstMatch(type);
      if (match != null) {
        final number = match.group(1)!;
        return int.tryParse(number) ?? 0;
      }
    }
    return 0;
  }

  (String entity, String key, String value) get backendSource {
    if (optionsSource == null) {
      throw Exception('Source is null');
    }

    // NOTE: more precise, tolerate hyphen or arrow-like separator within braces
    final pattern =
        r'(?<type>\w+)\.(?<entity>\w+)\(\{(?<key>\w+)\}-\{(?<value>\w+)\}\)';
    final regExp = RegExp(pattern);
    final match = regExp.firstMatch(optionsSource!);

    var entity = '';
    var key = '';
    var value = '';

    if (match != null) {
      entity = match.namedGroup('entity')!;
      key = match.namedGroup('key')!;
      value = match.namedGroup('value')!;
    }

    return (entity, key, value);
  }

  static Widget buildDisplay(
    EntityCustom entity,
    String label,
    dynamic value, [
    void Function()? onTap,
  ]) {
    if (value == null) {
      return const Text('-');
    }

    // NOTE: avoid firstWhere throwing if not found
    final field = entity.fields.firstWhere(
      (e) => e.reference == label,
      orElse: () => EntityField.empty(),
    );

    late Widget widget;
    if (field.isDateTime) {
      try {
        final date = DateTime.tryParse(value.toString()) ??
            DateFormat(field.dateTimeFormat).parse(value.toString());
        widget = Text(DateFormat(field.dateTimeFormat).format(date));
      } catch (_) {
        widget = Text(value.toString());
      }
    } else if (field.isBool) {
      widget = BoolIcon(value == 1);
    } else if (field.isPermission) {
      final access = Access.fromValue(int.tryParse(value.toString()) ?? 0);
      widget = Wrap(
        spacing: 3,
        runSpacing: 3,
        children: access.permissions.entries.map((entry) {
          return Chip(
            label: Text(entry.key.tr(),
                style: const TextStyle(color: Colors.white)),
            backgroundColor: entry.value
                ? (Access.permissionColors[entry.key] ?? Colors.grey)
                : Colors.grey.shade400,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(4),
              side: const BorderSide(color: Colors.transparent),
            ),
          );
        }).toList(),
      );
    } else if (field.isNumber) {
      if (value is num) {
        widget = Text(value.format(field.decimal));
      } else {
        final parsed = num.tryParse(value.toString());
        widget = Text(parsed?.format(field.decimal) ?? 'type is not number');
      }
    } else {
      widget = Text(LayoutListTile.getValue(value));
    }

    if (widget is Text && onTap != null) {
      // return widget.canCopy(onTap: onTap);
      return widget.canCopy();
    }
    return widget;
  }

  bool _enabled(DataAction action) {
    if (action == DataAction.create) {
      return allowCreate ?? false;
    } else if (action == DataAction.edit) {
      return allowUpdate ?? false;
    } else {
      return false;
    }
  }

  Widget buildFieldBool(
    DataAction action,
    TextEditingController controller,
    bool isEnabled,
  ) {
    final value = controller.text == '1';
    return AbsorbPointer(
      absorbing: !isEnabled,
      child: FieldCheckBox(
        label: label,
        initialValue: value,
        onChanged: (value) => controller.text = value ? '1' : '0',
      ),
    );
  }

  Widget buildFieldPermission(
    DataAction action,
    TextEditingController controller,
    bool isEnabled,
  ) {
    return AbsorbPointer(
      absorbing: !isEnabled,
      child: FieldCheckboxPermission(
        initialValue: Access.fromValue(int.tryParse(controller.text) ?? 0),
        onChanged: (value) {
          controller.text = value.getValue().toString();
        },
      ),
    );
  }

  Widget buildFieldDateTime(
    DataAction action,
    TextEditingController controller,
    bool isEnabled,
  ) {
    final initialDate = action.isEdit
        ? (DateTime.tryParse(controller.text) ??
            DateFormat.yMMMMd().parse(controller.text))
        : null;
    return FieldDatePicker(
      labelText: label,
      initialSelectedDate: initialDate,
      controller: controller,
      validator: requiredObjectValidator.call,
    );
  }

  Widget buildFieldDropDown(
    DataAction action,
    TextEditingController controller,
    bool isEnabled,
  ) {
    return FDropDownSearchEntity(
      label: label,
      itemAsString: (id, label) => '$id - $label',
      entityField: this,
      initialValue: action.isEdit ? MapEntry(controller.text, '') : null,
      enabled: isEnabled,
      onChanged: (value) {
        controller.text = value!.key.toString();
      },
    );
  }

  Widget buildForm(DataAction action, TextEditingController controller) {
    final isEnabled = _enabled(action);
    if (optionsSource != null) {
      return buildFieldDropDown(action, controller, isEnabled);
    } else if (isDateTime) {
      return buildFieldDateTime(action, controller, isEnabled);
    } else if (isBool) {
      return buildFieldBool(action, controller, isEnabled);
    } else if (isPermission) {
      return buildFieldPermission(action, controller, isEnabled);
    }

    return buildFieldText(action, controller, isEnabled);
  }

  Widget buildFieldText(
    DataAction action,
    TextEditingController controller,
    bool isEnabled,
  ) {
    return FTextFormField(
      labelText: label,
      enabled: isEnabled,
      controller: controller,
      inputFormatters:
          isNumber ? [FilteringTextInputFormatter.digitsOnly] : null,
      validator: MultiValidator([
        if (required ?? false) requiredValidator,
        LengthValidator(
          minLength: minLength,
          maxLength: maxLength,
        ),
        if (pattern != null)
          PatternValidator(
            pattern!,
            errorText: patternError ?? 'Invalid format',
          ),
      ]),
    );
  }

  bool get isDateTime => type.contains('datetime');
  bool get isBool => type == 'bool';
  bool get isPermission => type == 'permission';
  bool get isNumber => type.contains('number');

  String get dateTimeFormat {
    final regex = RegExp(r'datetime\((.*?)\)');
    final match = regex.firstMatch(type);
    if (match != null) {
      final fmt = match.group(1);
      if (fmt != null && fmt.isNotEmpty) return fmt;
    }
    throw Exception('Invalid datetime format: "$type"');
  }

  Map<String, dynamic> toJson() {
    return {
      'options_source': optionsSource,
      'column_width': columnWidth,
      'label': label,
      'reference': reference,
      'type': type,
      'auto_generated': autoGenerated,
      'required': required,
      'pattern': pattern,
      'pattern_error': patternError,
      'min_length': minLength,
      'max_length': maxLength,
      'allow_create': allowCreate,
      'allow_update': allowUpdate,
    };
  }
}

class FieldOptions extends HiveObject {
  final String source;
  final String labelField;
  final String valueField;

  FieldOptions({
    required this.source,
    required this.labelField,
    required this.valueField,
  });

  factory FieldOptions.fromJson(Map<String, dynamic> json) {
    return FieldOptions(
      source: json['source'],
      labelField: json['label_field'],
      valueField: json['value_field'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'source': source,
      'label_field': labelField,
      'value_field': valueField,
    };
  }
}

extension EntityFieldList on List<EntityField> {
  Map<String, TextEditingController> generateControllers() {
    final map = <String, TextEditingController>{};
    for (final field in this) {
      map[field.reference] = TextEditingController();
    }
    return map;
  }

  int findIndex(String reference) {
    for (var i = 0; i < length; i++) {
      if (this[i].reference == reference) {
        return i;
      }
    }
    return -1;
  }
}
