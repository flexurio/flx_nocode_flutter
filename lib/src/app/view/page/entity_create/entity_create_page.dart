import 'package:flexurio_no_code/src/app/bloc/entity/entity_bloc.dart';
import 'package:flexurio_no_code/src/app/model/entity.dart' as configuration;
import 'package:flexurio_no_code/src/app/model/layout.dart';
import 'package:easy_localization/easy_localization.dart';
import 'package:flexurio_erp_core/flexurio_erp_core.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:gap/gap.dart';
import 'package:page_transition/page_transition.dart';

class EntityCreatePage extends StatefulWidget {
  const EntityCreatePage._(
    this.data,
    this.entity,
    this.onSuccess,
  );

  final Map<String, dynamic>? data;
  final configuration.EntityCustom entity;
  final VoidCallback onSuccess;

  static Route<bool?> route({
    required configuration.EntityCustom entity,
    Map<String, dynamic>? data,
    required VoidCallback onSuccess,
  }) {
    return PageTransition(
      opaque: true,
      type: PageTransitionType.rightToLeft,
      child: MultiBlocProvider(
        providers: [BlocProvider(create: (context) => EntityBloc(entity))],
        child: EntityCreatePage._(data, entity, onSuccess),
      ),
    );
  }

  @override
  State<EntityCreatePage> createState() => _EntityCreatePageState();
}

class _EntityCreatePageState extends State<EntityCreatePage> {
  final _formKey = GlobalKey<FormState>();
  final _controllers = <String, TextEditingController>{};
  late DataAction _action;

  @override
  void initState() {
    super.initState();

    for (final field in widget.entity.fields) {
      _controllers[field.reference] = TextEditingController();
    }

    _action = createOrEdit(widget.data);
    if (_action.isEdit) {
      for (final field in widget.entity.fields) {
        _controllers[field.reference]!.text =
            widget.data![field.reference].toString();
      }
    }
  }

  Map<String, dynamic> get _data {
    final data = <String, dynamic>{};
    for (final field in widget.entity.fields) {
      if (field.reference != 'id' && (field.autoGenerated ?? false)) {
        continue;
      }

      var value = _controllers[field.reference]!.text;
      if (field.isDateTime) {
        value = DateFormat('yMMMMd').parse(value).toUtcIso();
      }
      data[field.reference] = value;
    }
    return data;
  }

  void _submit() {
    if (_formKey.currentState!.validate()) {
      late EntityEvent event;
      if (_action.isEdit) {
        event = EntityEvent.edit(data: _data);
      } else {
        event = EntityEvent.create(data: _data);
      }

      context.read<EntityBloc>().add(event);
    }
  }

  @override
  Widget build(BuildContext context) {
    final coreEntity = widget.entity.coreEntity;
    return BlocListener<EntityBloc, EntityState>(
      listener: (context, state) {
        state.maybeWhen(
          success: (_) {
            widget.onSuccess();
            Toast(context).dataChanged(_action, coreEntity);
            Navigator.pop(context, true);
          },
          error: (error) => Toast(context).fail(error),
          orElse: () {},
        );
      },
      child: Scaffold(
        backgroundColor: Colors.transparent,
        body: SingleFormPanel(
          formKey: _formKey,
          action: _action,
          entity: coreEntity,
          actions: [_buildButtonSubmit()],
          children: [_buildForm()],
        ),
      ),
    );
  }

  Widget _buildButtonSubmit() {
    return BlocBuilder<EntityBloc, EntityState>(
      builder: (context, state) {
        return Button(
          permission: null,
          isInProgress: state.maybeWhen(
            loading: () => true,
            orElse: () => false,
          ),
          onPressed: _submit,
          action: _action,
        );
      },
    );
  }

  Widget _buildForm() {
    String action = 'create';
    if (_action.isEdit) {
      action = 'update';
    }

    final children = <Widget>[];
    final layouts = widget.entity.layout;
    final layoutEdit = layouts.containsKey(action);
    if (layoutEdit) {
      final layout = (layouts[action] as Map<String, dynamic>).entries;
      for (final entry in layout) {
        final layoutGroup = LayoutGroup.fromMapEntry(entry);
        final layout = layoutGroup.buildForm(
          widget.entity,
          _action,
          _controllers,
        );
        children.addAll([layout, Gap(24)]);
      }
      children.removeLast();
    } else {
      children.add(Text("Error: Layout \"$action\" not found"));
    }
    return Column(children: children);
  }
}
